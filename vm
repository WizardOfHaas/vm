#!/usr/bin/perl

use warnings;
use strict;

my $ip = 0;

my @regs = (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

my @mem = ((0) x 64);

my @jmp_stack;

open CODE, '<', $ARGV[0];
binmode(CODE);
my @code;
while(<CODE>)
{
    push(@code, unpack('C*', $_));
}

while($ip <= $#code)
{
    my @in = ($code[$ip], $code[$ip+1], $code[$ip+2], $code[$ip+3]);
    print join('|', @in)."\n";
    
    if($in[0] == ord('=')){#mov
	&op(\&mov, @in);
    }elsif($in[0] == ord('+')){#add
	&op(\&add, @in);
    }elsif($in[0] == ord('-')){#sub
	&op(\&dif, @in);
    }

    
    print join("|", @regs)."\n";
    print join("|", @mem)."\n";

    $ip += 4;
}

sub op
{
    my @in;
    (my $code, $in[0], $in[1], $in[2], $in[3]) = @_;
    
    if($in[1] == 0){ #reg = num
	$regs[$in[2]] = $code->($regs[$in[2]], $in[3]);
    }elsif($in[1] == 1){ #mem = num
	$mem[$in[2]] = $code->($mem[$in[2]], $in[3]);
    }elsif($in[1] == 2){ #reg = mem
	$regs[$in[2]] = $code->($regs[$in[2]], $mem[$in[3]]);
    }elsif($in[1] == 3){ #reg = reg
	$regs[$in[2]] = $code->($regs[$in[2]], $regs[$in[3]]);
    }elsif($in[1] == 4){ #mem = reg
	$mem[$in[2]] = $code->($mem[$in[2]], $regs[$in[3]]);
    }    
}

sub mov
{
    my ($a, $b) = @_;

    return $b;
}

sub add
{
    my ($a, $b) = @_;

    return $a + $b;
}

sub dif
{
    my ($a, $b) = @_;

    return $a - $b;
}
