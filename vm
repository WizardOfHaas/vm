#!/usr/bin/perl

use warnings;
use strict;

my $ip = 0;

my @regs = (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

my @mem = ((0) x 64);

my @jmp_stack;

open CODE, '<', $ARGV[0];
binmode(CODE);
my @code;
while(<CODE>)
{
    push(@code, unpack('C*', $_));
}

while($ip <= $#code)
{
    my @in = ($code[$ip], $code[$ip+1], $code[$ip+2], $code[$ip+3]);
    print join('|', @in)."\n";
    
    if($in[0] == ord('=')){#mov
	&op(\&mov, @in);
    }elsif($in[0] == ord('+')){#add
	&op(\&add, @in);
    }elsif($in[0] == ord('-')){#sub
	&op(\&dif, @in);
    }

    
    print join("|", @regs)."\n";
    print join("|", @mem)."\n\n";

    $ip += 4;
}

sub op
{
    my @in;
    (my $code, $in[0], $in[1], $in[2], $in[3]) = @_;
    
    if($in[1] == 0){ #reg = num #case 0
	$regs[$in[2]] = $code->($regs[$in[2]], $in[3]); # mov ax, 5
    }elsif($in[1] == 1){ #mem = num #case 1
	$mem[$in[2]] = $code->($mem[$in[2]], $in[3]); # mov [0x100], 5
    }elsif($in[1] == 2){ #reg = mem #case 2
	$regs[$in[2]] = $code->($regs[$in[2]], $mem[$in[3]]); # mov ax, [0x100]
    }elsif($in[1] == 3){ #reg = reg #case 3
	$regs[$in[2]] = $code->($regs[$in[2]], $regs[$in[3]]); # mov ax, bx
    }elsif($in[1] == 4){ #mem = reg #case 4
	$mem[$in[2]] = $code->($mem[$in[2]], $regs[$in[3]]); # mov [0x100], ax
    }elsif($in[1] == 5){ #mem@reg pointer = num #case 5
	$mem[$regs[$in[2]]] = $code->($regs[$in[2]], $in[3]); # mov [si], 5
    }elsif($in[1] == 6){ #mem@reg pointer = reg #casr 6
	$mem[$regs[$in[2]]] = $code->($regs[$in[2]], $regs[$in[3]]); # mov [si], ax
    }elsif($in[1] == 7){ #reg = mem@reg pointer #case 7
	$regs[$in[2]] = $code->($regs[$in[2]], $mem[$regs[$in[3]]]); # mov ax, [si]
    }
}

sub mov
{
    my ($a, $b) = @_;

    return $b;
}

sub add
{
    my ($a, $b) = @_;

    return $a + $b;
}

sub dif
{
    my ($a, $b) = @_;

    return $a - $b;
}
